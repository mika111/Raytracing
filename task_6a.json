{"camera":{"position":[-0.0003611148627306118,-0.0009027184779283782,0.005437826914461823],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex position in object space coordinates\nin vec3 vertexPosition;\n// Surface normal at the vertex in object space coordinates\nin vec3 vertexNormal;\n// Texture coordinates at that vertex\nin vec2 vertexTextureCoordinates;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\n// Main program for each vertex\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n}"},"fragment":{"source":"#version 300 es\n\n// For better performance less precision\nprecision highp float;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\nout vec4 fragColor;\n\n// Main program for each fragment = pixel candidate\nvoid main() {\n  fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}"}},"uniforms":{"value":{"lightPosition":{"value":[0,0,0,1]},"lightInCamspace":{"value":[true]},"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\n\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\nout vec3 origin;\nout vec3 dir;\n\n// Main program for each vertex of the render quad\nvoid main() {\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertexPosition.x*orthographicFOV*aspectRatio,vertexPosition.y*orthographicFOV,0);\n        dir_camSpace = vec3(0, 0, -1);\n    }\n    else { \n    // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertexPosition.x*aspectRatio,vertexPosition.y,-1.0/tan(radians(perspectiveFOV)));\n}\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n    gl_Position = vec4(vertexPosition, 1.0);\n    \n    gl_Position = vec4(vertexPosition, 1.0);\n    fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n#define MAXFLOAT 3.402823466e+38\n#define pI 3.14\nprecision highp float;\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\nuniform float lightintense;\n\nuniform vec3 lightcolour;\nuniform vec4 lightPosition;\n\nin vec3 origin;\nin vec3 dir;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\nstruct LightSource\n{\nvec3 origin;\nvec3 colour;\nfloat intensity;\n};\n\nstruct Ray {\nvec3 origin;\nvec3 direction;\n};\n\nstruct Sphere {\nfloat radius;\nvec3 centre;\nvec3 colour;\n};\n\nstruct Plane {\nvec3 point;\nvec3 normal;\nvec3 colour;\n};\n\nstruct Intersection {\nvec3 point;\nvec3 normal;\nvec3 colour;\nvec3 origin;\nbool found;\nbool occluded;\n};\n\nstruct Planecheck {\nvec3 point;\nvec3 normal;\nvec3 colour;\nbool parallel;\n};\n\nvec3 illuminatesphere(vec3 point,inout LightSource lightsource,inout Sphere sphere) {\n    float pi = 3.14;\n    float len = length(lightsource.origin - point);\n    vec3 normal = normalize(point - sphere.centre);\n    vec3 lightdir = normalize(lightsource.origin - point);\n    vec3 view = normalize(point - origin);\n    vec3 reflect = normalize(2.0*max(dot(normal,lightdir),0.0)*normal - lightdir);\n    vec3 background = 0.4*sphere.colour;\n    vec3 diffuselight = 0.4*sphere.colour * lightsource.intensity*max(dot(normal,lightdir),0.0);\n    vec3 speclight = 0.15*sphere.colour *lightsource.intensity*pow(max(dot(-reflect,view),0.0),32.0);\n    float dimfactor = (lightsource.intensity/(4.0*pi*len*len));\n    return dimfactor*(background + speclight + diffuselight);\n}\n\nvec4 checkintersect(inout Ray ray,inout Sphere sphere){\n    \n    vec3 distancevec;\n    vec3 deltap = ray.origin - sphere.centre;\n    float discriminant = pow(dot(normalize(ray.direction),deltap),2.0) - pow(length(deltap),2.0) + pow(sphere.radius,2.0);\n\n    if (discriminant >= 0.0)\n    {\n        float mu1 = -dot(deltap,normalize(ray.direction)) - sqrt(discriminant);\n        float mu2 = -dot(deltap,normalize(ray.direction)) + sqrt(discriminant);\n        if (min(mu1,mu2) <0.0){return vec4(0.0,0.0,0.0,0.0);}\n        return vec4(min(mu1,mu2) * normalize(ray.direction) + ray.origin,1.0);\n    }\n    \n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nbool shadowchecker(vec3 point,inout LightSource lightsource,inout Sphere sphere[6],int n){\n    \n    Ray shadowray;\n    shadowray.origin = point;\n    shadowray.direction = normalize(lightsource.origin - point);\n\n    for(int j = 0;j<n;j++)\n        {\n            if (checkintersect(shadowray,sphere[j])[3] == 1.0){return false;}\n        }\n    for(int j = n+1;j<6;j++)\n        {\n            if (checkintersect(shadowray,sphere[j])[3] == 1.0){return false;}\n        }\n    return true;}\n\nbool shadowchecker2(vec3 point,inout LightSource lightsource,inout Sphere sphere[6],int n){\n    \n    Ray shadowray;\n    shadowray.origin = point;\n    shadowray.direction = normalize(lightsource.origin - point);\n    for(int j = 0;j<6;j++)\n        {\n            if (checkintersect(shadowray,sphere[j])[3] == 1.0){return false;}\n        }\n    return true;}\n\nPlanecheck checkplane(inout Ray ray,inout Plane plane,inout LightSource lightsource,inout Sphere sphere[6])\n    {\n        Planecheck planecheck;\n        planecheck.parallel = true;\n        planecheck.point= vec3(0.0,0.0,0.0);\n        planecheck.normal = vec3(0.0,0.0,0.0);\n        planecheck.colour = vec3(0.0,0.0,0.0);\n        if (dot(plane.normal,ray.direction) != 0.0)\n        {\n            \n            float dist = dot(plane.point - ray.origin,plane.normal)/dot(ray.direction,plane.normal);\n            vec3 intersectionpoint = ray.origin + dist*ray.direction;\n            if (dist < 0.0)\n                {\n                    \n                    return planecheck;}\n            planecheck.point = intersectionpoint;\n            planecheck.normal = plane.normal;\n\n        planecheck.parallel = false;\n        //check checkerboard\n            vec3 v1 = normalize(plane.point - dot(plane.point,plane.normal));\n            vec3 v2 = normalize(cross(v1,plane.normal));\n            float d1 = floor(dot(intersectionpoint - plane.point, 4.0*v1));\n            float d2 = floor(dot(intersectionpoint - plane.point, 4.0*v2));\n        \n        if ((mod(abs(d1-d2),2.0) == 1.0) && dist>0.0){\n                float pi = 3.14;\n                float len = length(lightsource.origin - intersectionpoint);\n                vec3 normal = normalize(plane.normal);\n                vec3 lightdir = normalize(lightsource.origin - intersectionpoint);\n                vec3 view = normalize(intersectionpoint - origin);\n                vec3 reflect = normalize(2.0*max(dot(normal,lightdir),0.0)*normal - lightdir);\n                vec3 background = 0.2*vec3(1.0,1.0,1.0);\n                vec3 diffuselight = 0.3*vec3(1.0,1.0,1.0) * lightsource.intensity*max(dot(normal,lightdir),0.0);\n                vec3 speclight = 0.9*vec3(1.0,1.0,1.0) *lightsource.intensity*pow(max(dot(-reflect,view),0.0),32.0);\n                float dimfactor = (lightsource.intensity/(4.0*pi*len*len));\n                if (!shadowchecker2(intersectionpoint, lightsource,sphere,0))\n                {planecheck.colour = vec3(0.0,0.0,0.0);}\n                else\n                {planecheck.colour = dimfactor*(background + speclight + diffuselight);}\n        }else{\n            planecheck.colour = vec3(0.2,0.2,0.2);\n        }\n    }\n        return planecheck;\n    }\n\nRay createsecondaryray(inout Ray primaryray,inout Intersection intersection)\n{\n    primaryray.origin = 0.001 *normalize(intersection.normal) + intersection.point;\n    primaryray.direction = primaryray.direction - (dot(2.0*primaryray.direction,intersection.normal))*intersection.normal;\n    return primaryray;\n}\n\nIntersection checkall(Ray primaryray,inout Sphere sphere[6],inout Plane plane,inout LightSource lamp1)\n\n{\n    float mindistance = MAXFLOAT;\n    Intersection intersection;\n    intersection.found = true;\n    Planecheck planeinfo = checkplane(primaryray,plane,lamp1,sphere);\n    intersection.colour = planeinfo.colour;\n    intersection.normal = planeinfo.normal;\n    intersection.point = planeinfo.point;\n    intersection.origin = primaryray.origin;\n    mindistance = length(intersection.point - primaryray.origin);\n    if (planeinfo.parallel == true){\n        intersection.found = false;\n        mindistance = MAXFLOAT;\n    }\n        for(int i = 0;i < 6;i++)\n    {\n        vec4 pos = checkintersect(primaryray,sphere[i]);\n        if (pos[3] == 1.0)\n        {\n            float distance = length(primaryray.origin - pos.xyz);\n            if (distance<=mindistance)\n            {\n                if (shadowchecker(pos.xyz, lamp1,sphere,i))\n                {intersection.colour = (illuminatesphere(pos.xyz, lamp1,sphere[i]));\n                }\n                else\n                {\n                intersection.colour = 0.1*sphere[i].colour;\n                intersection.occluded = true;\n                }\n                mindistance = distance;\n                intersection.point = pos.xyz;\n                intersection.origin = primaryray.origin;\n                intersection.normal = normalize(sphere[i].centre - pos.xyz);\n                intersection.found = true;\n            }\n        }\n    }    \n    return intersection;\n}\nfloat attenuate(float a){\n    if (a < 1.0)\n    {return 1.0;}\n}\n// Main program for each fragment of the render quad\nvoid main() {\n    //setting the scene\n    Sphere sphere[6];\n    Plane plane;\n    LightSource lamp1;\n    lamp1.origin = vec3(lightPosition);\n    lamp1.colour = lightcolour;\n    lamp1.intensity = lightintense * (1.0+length(lightPosition)); \n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n    plane.point = vec3(0,-0.5, 0);\n    plane.normal = vec3(0, 1.0, 0);\n    plane.colour = vec3(1, 1, 1);\n\n    const int depth = 3;\n    Intersection intersections[depth];\n    intersections[0].colour = vec3(0.0,0.0,0.0);\n    intersections[1].colour = vec3(0.0,0.0,0.0);\n    intersections[2].colour = vec3(0.0,0.0,0.0);\n\n    Ray primaryray;\n    primaryray.origin = origin;\n    primaryray.direction = dir;\n\n    int broken = 0;\n    for(int m = 0;m < depth;m++)\n    {\n        intersections[m] = checkall(primaryray,sphere,plane,lamp1);\n        if (intersections[m].found == false){\n            broken = m;\n            break;\n        }\n        primaryray = createsecondaryray(primaryray,intersections[m]);\n    }\n\n    vec3 col;\n\n    if (broken == 1){col = intersections[depth - 3].colour + 0.3*(1.0/length(intersections[depth - 2].origin - intersections[depth - 2].point))*intersections[depth - 3].colour;}\n   else{\n    float att[2];\n    att[0] = (1.0/(1.0 + length(intersections[depth - 1].origin - intersections[depth - 1].point)));\n    att[1] = (1.0/(1.0 + length(intersections[depth - 2].origin - intersections[depth - 2].point)));\n    col = intersections[depth - 2].colour + 5.0*intersections[depth - 2].colour*att[0]*intersections[depth - 1].colour;\n    col = intersections[depth - 3].colour + 5.0*intersections[depth - 3].colour*att[1]*col;\n   }\n    fragColor = vec4(col,1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"textureRendered":{"attachment":"Quad/R2T Pass color"},"lightintense":{"value":[7]},"lightcolour":{"value":[1,1,1]},"lightPosition":{"value":[6,4,3,0]}}}}}},"output":{"image":"Quad/R2T Pass color"}}