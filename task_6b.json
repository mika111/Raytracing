{"camera":{"position":[-0.0007349325472386713,-0.00033543917524664167,0.003493761877370241],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex position in object space coordinates\nin vec3 vertexPosition;\n// Surface normal at the vertex in object space coordinates\nin vec3 vertexNormal;\n// Texture coordinates at that vertex\nin vec2 vertexTextureCoordinates;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\n// Main program for each vertex\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n}"},"fragment":{"source":"#version 300 es\n\n// For better performance less precision\nprecision highp float;\n\nuniform vec4 lightPosition;\nuniform bool lightInCamspace;\n\nout vec4 fragColor;\n\n// Mainprogram for each fragment = pixel candidate\nvoid main() {\n  fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}"}},"uniforms":{"value":{"lightPosition":{"value":[0,0,0,1]},"lightInCamspace":{"value":[true]},"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\nout vec3 vertexP;\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\n\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\nout vec3 origin;\nout vec3 dir;\n\n// Main program for each vertex of the render quad\nvoid main() {\n    vertexP = vertexPosition;\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertexPosition.x*orthographicFOV*aspectRatio,vertexPosition.y*orthographicFOV,0);\n        dir_camSpace = vec3(0, 0, -1);\n    }\n    else { \n    // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertexPosition.x*aspectRatio,vertexPosition.y,-1.0/tan(radians(perspectiveFOV)));\n}\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n    gl_Position = vec4(vertexPosition, 1.0);\n    \n    gl_Position = vec4(vertexPosition, 1.0);\n    fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n#define MAXFLOAT 3.402823466e+38\n#define pI 3.14\nprecision highp float;\n\n//I have commented out my code because labts times out\n\n/*here I have added fog and soft shadows\n \nTo add soft shadows I have extended the existing shadow checker to shoot shadow rays whose direction vector has been modified \nby a small pseudo random number.The random number is generated using a custom function that takes in the rasterized vertex coords\nand passes them into a sin and cos function before dotting them with some random numbers to form a vector of random numbers. \nThis is then multiplied by the uniform shadowvar (stands for shadow variance) which lets the user control how wide the sampling \ndomain for the pseudo random vector is. These shadow rays are then calculated as normal (if there is a hit then color = 0 \nelse do Phong lighting) and averaged. There are 4 of these shadow rays per occluded pixel.\n\nTo add fog i first set any pixel whose ray does not hit anything to white (as in essence all you can see is fog)\nand then attenuated the intensity of the colour values calculated by an exponential function (with ray distance in the exponent) and added to it pure \nwhite attenuated by a positive exponential function. These exponentials contain a uniform float as part of their exponent called fogthickness.\nThis can be adjusted to simulate various fog thicknesses.\n*/\n\n//Code is below\n\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\nuniform float lightintense;\nuniform vec3 lightposition;\nuniform vec3 lightcolour;\nuniform float fogthickness;\nuniform float shadowvar;\nin vec3 origin;\nin vec3 dir;\nin vec3 vertexP;\n\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n\nstruct LightSource\n{\nvec3 origin;\nvec3 colour;\nfloat intensity;\n};\n\nstruct Ray {\nvec3 origin;\nvec3 direction;\n};\n\nstruct Sphere {\nfloat radius;\nvec3 centre;\nvec3 colour;\n};\n\nstruct Plane {\nvec3 point;\nvec3 normal;\nvec3 colour;\n};\n\nstruct Intersection {\nvec3 point;\nvec3 normal;\nvec3 colour;\nvec3 origin;\nbool found;\nbool occluded;\n};\n\nstruct Planecheck {\nvec3 point;\nvec3 normal;\nvec3 colour;\nbool parallel;\n};\n\nvec3 illuminatesphere(vec3 point,inout LightSource lightsource,inout Sphere sphere) {\n    float pi = 3.14;\n    float len = length(lightsource.origin - point);\n    vec3 normal = normalize(point - sphere.centre);\n    vec3 lightdir = normalize(lightsource.origin - point);\n    vec3 view = normalize(point - origin);\n    vec3 reflect = normalize(2.0*max(dot(normal,lightdir),0.0)*normal - lightdir);\n    vec3 background = 0.1*sphere.colour;\n    vec3 diffuselight = 0.3*sphere.colour * lightsource.intensity*max(dot(normal,lightdir),0.0);\n    vec3 speclight = 0.25*sphere.colour *lightsource.intensity*pow(max(dot(-reflect,view),0.0),32.0);\n    float dimfactor = (lightsource.intensity/(4.0*pi*len*len));\n    return dimfactor*(background + speclight + diffuselight);\n}\n\nvec4 checkintersect(inout Ray ray,inout Sphere sphere){\n    \n    vec3 distancevec;\n    vec3 deltap = ray.origin - sphere.centre;\n    float discriminant = pow(dot(normalize(ray.direction),deltap),2.0) - pow(length(deltap),2.0) + pow(sphere.radius,2.0);\n\n    if (discriminant >= 0.0)\n    {\n        float mu1 = -dot(deltap,normalize(ray.direction)) - sqrt(discriminant);\n        float mu2 = -dot(deltap,normalize(ray.direction)) + sqrt(discriminant);\n        if (min(mu1,mu2) <0.0){return vec4(0.0,0.0,0.0,0.0);}\n        return vec4(min(mu1,mu2) * normalize(ray.direction) + ray.origin,1.0);\n    }\n    \n    return vec4(0.0,0.0,0.0,0.0);\n}\n\nbool shadowchecker(vec3 point,inout LightSource lightsource,inout Sphere sphere[6],int n, vec3 buffer){\n    \n    Ray shadowray;\n    shadowray.origin = point;\n    shadowray.direction = normalize(lightsource.origin - point) + buffer;\n\n    for(int j = 0;j<n;j++)\n        {\n            if (checkintersect(shadowray,sphere[j])[3] == 1.0){return false;}\n        }\n    for(int j = n+1;j<6;j++)\n        {\n            if (checkintersect(shadowray,sphere[j])[3] == 1.0){return false;}\n        }\n    return true;}\nvec3 random(vec3 seed){\n    return shadowvar*fract(vec3(0.5 + cos(dot(seed,vec3(21.4,31.7,51.4))) + sin(dot(seed,vec3(21.1,12.7,20.4)))));\n}\n\n\nbool shadowchecker2(vec3 point,inout LightSource lightsource,inout Sphere sphere[6],int n,vec3 buffer){\n    \n    Ray shadowray;\n    shadowray.origin = point;\n    shadowray.direction = normalize(lightsource.origin - point) + buffer;\n    for(int j = 0;j<6;j++)\n        {\n            if (checkintersect(shadowray,sphere[j])[3] == 1.0){return false;}\n        }\n    return true;}\n\nPlanecheck checkplane(inout Ray ray,inout Plane plane,inout LightSource lightsource,inout Sphere sphere[6])\n    {\n        Planecheck planecheck;\n        planecheck.parallel = true;\n        planecheck.point= vec3(0.0,0.0,0.0);\n        planecheck.normal = vec3(0.0,0.0,0.0);\n        planecheck.colour = vec3(0.0,0.0,0.0);\n        if (dot(plane.normal,ray.direction) != 0.0)\n        {\n            \n            float dist = dot(plane.point - ray.origin,plane.normal)/dot(ray.direction,plane.normal);\n            vec3 intersectionpoint = ray.origin + dist*ray.direction;\n            if (dist < 0.0)\n                {\n                    \n                    return planecheck;\n                    }\n            planecheck.point = intersectionpoint;\n            planecheck.normal = plane.normal;\n\n        planecheck.parallel = false;\n        //check checkerboard\n            vec3 v1 = normalize(plane.point - dot(plane.point,plane.normal));\n            vec3 v2 = normalize(cross(v1,plane.normal));\n            float d1 = floor(dot(intersectionpoint - plane.point, 4.0*v1));\n            float d2 = floor(dot(intersectionpoint - plane.point, 4.0*v2));\n        \n        if ((mod(abs(d1-d2),2.0) == 1.0) && dist>0.0){\n                float pi = 3.14;\n                float len = length(lightsource.origin - intersectionpoint);\n                vec3 normal = normalize(plane.normal);\n                vec3 lightdir = normalize(lightsource.origin - intersectionpoint);\n                vec3 view = normalize(intersectionpoint - origin);\n                vec3 reflect = normalize(2.0*max(dot(normal,lightdir),0.0)*normal - lightdir);\n                vec3 background = 0.2*vec3(1.0,1.0,1.0);\n                vec3 diffuselight = 0.4*vec3(1.0,1.0,1.0) * lightsource.intensity*max(dot(normal,lightdir),0.0);\n                vec3 speclight = 0.9*vec3(1.0,1.0,1.0) *lightsource.intensity*pow(max(dot(-reflect,view),0.0),32.0);\n                float dimfactor = (lightsource.intensity/(4.0*pi*len*len));\n                if (!shadowchecker2(intersectionpoint, lightsource,sphere,0,vec3(0.0,0.0,0.0)))\n                {\n                vec3 rand = random(vertexP);\n                int num = 1;\n                for (int z = 0;z<3; z++){\n                    if ((shadowchecker2(intersectionpoint, lightsource,sphere,0,rand[z]*vec3(0.0,0.0,0.0))))\n                    {planecheck.colour += dimfactor*(background + speclight + diffuselight);\n                    num ++;}\n                }\n                planecheck.colour = planecheck.colour/float(num);}\n                else\n                {planecheck.colour = dimfactor*(background + speclight + diffuselight);}\n        }else{\n            planecheck.colour = vec3(0.2,0.2,0.2);\n        }\n    }\n        return planecheck;\n    }\n\nRay createsecondaryray(inout Ray primaryray,inout Intersection intersection)\n{\n    primaryray.origin = 0.001 *normalize(intersection.normal) + intersection.point;\n    primaryray.direction = primaryray.direction - (dot(2.0*primaryray.direction,intersection.normal))*intersection.normal;\n    return primaryray;\n}\n\nIntersection checkall(Ray primaryray,inout Sphere sphere[6],inout Plane plane,inout LightSource lamp1)\n\n{\n    float mindistance = MAXFLOAT;\n    Intersection intersection;\n    intersection.found = true;\n    Planecheck planeinfo = checkplane(primaryray,plane,lamp1,sphere);\n    intersection.colour = planeinfo.colour;\n    intersection.normal = planeinfo.normal;\n    intersection.point = planeinfo.point;\n    intersection.origin = primaryray.origin;\n    mindistance = length(intersection.point - primaryray.origin);\n    if (planeinfo.parallel == true){\n        intersection.found = false;\n        mindistance = MAXFLOAT;\n    }\n        for(int i = 0;i < 6;i++)\n    {\n        vec4 pos = checkintersect(primaryray,sphere[i]);\n        if (pos[3] == 1.0)\n        {\n            float distance = length(primaryray.origin - pos.xyz);\n            if (distance<=mindistance)\n            {\n                if (shadowchecker(pos.xyz, lamp1,sphere,i,vec3(0.0,0.0,0.0)))\n                {intersection.colour = (illuminatesphere(pos.xyz, lamp1,sphere[i]));\n                }\n                else\n                {\n                vec3 colour = vec3(0.0,0.0,0.0);\n                vec3 rand = random(vertexP);\n                int num = 1;\n                for (int z = 0;z<3; z++){\n                    if ((shadowchecker(pos.xyz, lamp1,sphere,i,rand[z]*vec3(0.0,0.0,0.0))))\n                        {intersection.colour += (illuminatesphere(pos.xyz, lamp1,sphere[i]));\n                        num ++;}\n                }\n                intersection.colour = intersection.colour/float(num);\n                intersection.occluded = true;\n                }\n                mindistance = distance;\n                intersection.point = pos.xyz;\n                intersection.origin = primaryray.origin;\n                intersection.normal = normalize(sphere[i].centre - pos.xyz);\n                intersection.found = true;\n            }\n        }\n    }    \n    return intersection;\n}\n\n// Main program for each fragment of the render quad\nvoid main() {\n    //setting the scene\n    Sphere sphere[6];\n    Plane plane;\n    LightSource lamp1;\n    lamp1.origin = lightposition;\n    lamp1.colour = lightcolour;\n    lamp1.intensity = lightintense; \n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n    plane.point = vec3(0,-0.5, 0);\n    plane.normal = vec3(0, 1.0, 0);\n    plane.colour = vec3(1, 1, 1);\n\n    const int depth = 3;\n    Intersection intersections[depth];\n    Ray primaryray;\n    primaryray.origin = origin;\n    primaryray.direction = dir;\n\n\n    for(int l = 0;l < depth;l++)\n    {\n        intersections[l] = checkall(primaryray,sphere,plane,lamp1);\n        if (intersections[l].found == false){\n            break;\n        }\n        primaryray = createsecondaryray(primaryray,intersections[l]);\n    }\n\n    vec3 col;\n    col = intersections[depth - 2].colour + 0.7*exp(-fogthickness*2.0 * length(intersections[depth-1].origin - intersections[depth-1].point))*intersections[depth - 1].colour;\n    col += intersections[depth - 3].colour + 0.7*exp(-fogthickness*2.0 * length(intersections[depth-2].origin - intersections[depth-2].point))*col;\n\n    col = 0.75*col*exp(-fogthickness*2.0 * length(intersections[0].origin - intersections[0].point));\n    col = col*1.0/(fogthickness*2.0 * length(intersections[0].origin - intersections[0].point));\n    if (intersections[0].found == false){\n        fragColor = vec4(1.0,1.0,1.0,0.8);\n    }else{\n    fragColor = vec4((col + 0.3*vec3(1.0,1.0,1.0)*pow(length(intersections[0].origin - intersections[0].point),1.0)*fogthickness),0.8); \n    }}\n    "}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"textureRendered":{"value":{"TEXTURE_2D":""}},"lightintense":{"value":[67]},"lightposition":{"value":[6,2,3]},"lightcolour":{"value":[0,0,0]},"fogthickness":{"value":[0.8]},"shadowvar":{"value":[0.9]}}}}}},"output":{"image":"Quad/R2T Pass color"}}